"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePluginStyle = exports.useActionEffect = exports.useActionTrigger = exports.useInteraction = exports.useVariable = exports.useConfig = exports.usePaginatedElementData = exports.useElementData = exports.useElementColumns = exports.useLoadingState = exports.useEditorPanelConfig = exports.usePlugin = void 0;
const react_1 = require("react");
const Context_1 = require("./Context");
const deepEqual_1 = require("../utils/deepEqual");
/**
 * Gets the entire plugin instance
 * @returns {PluginInstance} Context for the current plugin instance
 */
function usePlugin() {
    return (0, react_1.useContext)(Context_1.PluginContext);
}
exports.usePlugin = usePlugin;
/**
 * Provides a setter for the Plugin's Config Options
 * @param {CustomPluginConfigOptions[]} nextOptions Updated possible Config Options
 */
function useEditorPanelConfig(nextOptions) {
    const client = usePlugin();
    const optionsRef = (0, react_1.useRef)({});
    (0, react_1.useEffect)(() => {
        if (nextOptions == null)
            return;
        if (!(0, deepEqual_1.deepEqual)(nextOptions, optionsRef.current)) {
            client.config.configureEditorPanel(nextOptions);
            optionsRef.current = nextOptions;
        }
    }, [client, nextOptions]);
}
exports.useEditorPanelConfig = useEditorPanelConfig;
/**
 * React hook for Plugin Config loading state
 * @param {boolean} initialState Initial value to set loading state to
 * @returns {[boolean, Function]} Boolean value corresponding to loading state for plugin config and setter for loading state
 */
function useLoadingState(initialState) {
    const client = usePlugin();
    const [loading, setLoading] = (0, react_1.useState)(() => {
        client.config.setLoadingState(initialState);
        return initialState;
    });
    return [
        loading,
        nextState => {
            if (nextState === loading)
                return;
            setLoading(nextState);
            client.config.setLoadingState(nextState);
        },
    ];
}
exports.useLoadingState = useLoadingState;
/**
 * Provides the latest column values from corresponding config element
 * @param {string} configId ID from the config for fetching element columns, with type: 'element'
 * @returns {WorkbookElementColumns} Values of corresponding columns contained
 * within the config element
 */
function useElementColumns(configId) {
    const client = usePlugin();
    const [columns, setColumns] = (0, react_1.useState)({});
    (0, react_1.useEffect)(() => {
        if (configId) {
            return client.elements.subscribeToElementColumns(configId, setColumns);
        }
    }, [client, configId]);
    return columns;
}
exports.useElementColumns = useElementColumns;
/**
 * Provides the latest data values from config element (max 25_000)
 * @param {string} configId ID from the config for fetching element data, with type: 'element'
 * @returns {WorkbookElementData} Element Data for config element, if any
 */
function useElementData(configId) {
    const client = usePlugin();
    const [data, setData] = (0, react_1.useState)({});
    (0, react_1.useEffect)(() => {
        if (configId) {
            return client.elements.subscribeToElementData(configId, setData);
        }
    }, [client, configId]);
    return data;
}
exports.useElementData = useElementData;
/**
 * Provides the latest data values from corresponding config element with a callback to
 * fetch more in chunks of 25_000 data points
 * @param {string} configId ID from the config for fetching paginated
 * element data, with type: 'element'
 * @returns {WorkbookElementData} Element Data for configured config element, if any
 */
function usePaginatedElementData(configId) {
    const client = usePlugin();
    const [data, setData] = (0, react_1.useState)({});
    const loadMore = (0, react_1.useCallback)(() => {
        if (configId) {
            client.elements.fetchMoreElementData(configId);
        }
    }, [configId]);
    (0, react_1.useEffect)(() => {
        if (configId) {
            return client.elements.subscribeToElementData(configId, setData);
        }
    }, [client, configId]);
    return [data, loadMore];
}
exports.usePaginatedElementData = usePaginatedElementData;
/**
 * Provides the latest value for entire config or certain key within the config
 * @param {string} key Key within Plugin Config, optional
 * @returns Entire config if no key passed in or value for key within plugin config
 */
function useConfig(key) {
    const client = usePlugin();
    const [config, setConfig] = (0, react_1.useState)(key != null ? client.config.getKey(key) : client.config.get());
    (0, react_1.useEffect)(() => client.config.subscribe(newConfig => {
        if (key != null && newConfig[key] !== config[key]) {
            setConfig(newConfig[key]);
        }
        else {
            setConfig(newConfig);
        }
    }), [client]);
    return config;
}
exports.useConfig = useConfig;
/**
 * React hook for accessing a workbook control variable
 * @param {string} id ID from the config of type: 'variable'
 * @returns {[(WorkbookVariable | undefined), Function]} Constantly updating
 * value of the control variable and setter for the variable
 */
function useVariable(id) {
    const client = usePlugin();
    const [workbookVariable, setWorkbookVariable] = (0, react_1.useState)();
    const isFirstRender = (0, react_1.useRef)(true);
    (0, react_1.useEffect)(() => {
        if (isFirstRender.current) {
            setWorkbookVariable(client.config.getVariable(id));
            isFirstRender.current = false;
        }
        return client.config.subscribeToWorkbookVariable(id, setWorkbookVariable);
    }, [client, id]);
    const setVariable = (0, react_1.useCallback)((...values) => client.config.setVariable(id, ...values), [id]);
    return [workbookVariable, setVariable];
}
exports.useVariable = useVariable;
/**
 * @deprecated Use Action API instead
 * React hook for accessing a workbook interaction selections state
 * @param {string} id ID from the config of type: 'interaction'
 * @returns {[(WorkbookSelection | undefined), Function]} Constantly updating selection state and setter thereof
 */
function useInteraction(id, elementId) {
    const client = usePlugin();
    const [workbookInteraction, setWorkbookInteraction] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        return client.config.subscribeToWorkbookInteraction(id, setWorkbookInteraction);
    }, [client, id]);
    const setInteraction = (0, react_1.useCallback)((value) => {
        client.config.setInteraction(id, elementId, value);
    }, [id]);
    return [workbookInteraction, setInteraction];
}
exports.useInteraction = useInteraction;
/**
 * React hook for returning a triggering callback function for the registered
 * action trigger
 * @param {string} configId ID from the config of type: 'action-trigger'
 * @returns {Function} A callback function to trigger the action
 */
function useActionTrigger(configId) {
    const client = usePlugin();
    return (0, react_1.useCallback)(() => {
        client.config.triggerAction(configId);
    }, [client, configId]);
}
exports.useActionTrigger = useActionTrigger;
/**
 * React hook for registering and unregistering an action effect
 * @param {string} configId ID from the config of type: 'action-effect'
 * @param {Function} effect The function to be called when the action is triggered
 */
function useActionEffect(configId, effect) {
    const client = usePlugin();
    const effectRef = (0, react_1.useRef)(effect);
    (0, react_1.useEffect)(() => {
        effectRef.current = effect;
    });
    (0, react_1.useEffect)(() => {
        return client.config.registerEffect(configId, effectRef.current);
    }, [client, configId, effect]);
}
exports.useActionEffect = useActionEffect;
/**
 * React hook for accessing plugin style with live updates
 * @returns {PluginStyle | undefined} Style properties from the workbook if available
 */
function usePluginStyle() {
    const client = usePlugin();
    const [style, setStyle] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        // Request initial style data on mount and subscribe to updates
        void client.style.get().then(response => setStyle(response));
        return client.style.subscribe(setStyle);
    }, [client]);
    return style;
}
exports.usePluginStyle = usePluginStyle;
